pragma solidity ^0.6.0;

// Define a contract 'Supplychain'

import "../Toneraccesscontrols/SupplierRole.sol";
import "../Toneraccesscontrols/TransporterRole.sol";
import "../Toneraccesscontrols/DistributorRole.sol";
import "../Toneraccesscontrols/ProcessingfactoryRole.sol";
import "../Toneraccesscontrols/RetailerRole.sol";
import "../Toneraccesscontrols/ConsumerRole.sol";

contract SupplyChain is SupplierRole, TransporterRole, DistributorRole, ProcessingfactoryRole, RetailerRole, ConsumerRole {

  // Define 'owner'
    address private owner;

  // Define a variable called 'upc' for Universal Product Code (UPC)
    uint  upc;

    // Define a variable called 'sku' for Stock Keeping Unit (SKU)
    uint  sku;
    
    // Define enum 'State' with the following values:
    enum State 
    {             
      SoldToProcessingfactory,      //0
      ShippedToProcessingfactory,   //1
      ReceivedByProcessingfactory,  //2
      Working,                      //3
      SoldToDistributor,            //4
      ShippedToDistributor,         //5
      ReceivedByDistributor,        //6
      SoldToRetailer,               //7
      ShippedToRetailer,            //8
      ReceivedByRetailer,           //9
      Purchased                     //10
    }
    
    // Define a struct 'Item' with the following fields:
    struct Item {
        uint    sku;                // Stock Keeping Unit (SKU)
        uint    upc;                // Universal Product Code (UPC), generated by the Farmer, goes on the package, can be verified by the Consumer
        address payable ownerID;            // Metamask-Ethereum address of the current owner as the product moves through 11 stages
        address payable originID;           // Metamask-Ethereum address of the Supplier
        uint    productID;          // Product ID potentially a combination of upc + sku
        string  productNotes;       // Product Notes
        uint    productprice;       // Product Price
        State   itemState;          // Product State as represented in the enum above
        address payable transporterID;     // Metamask-Ethereum address of the Transporter (Supplier --> Processingfactory)
        address payable distributorID;      // Metamask-Ethereum address of the Distributor
        address payable processingfactoryID;// Metamask-Ethereum address of the Processingfactory
        address payable retailerID;         // Metamask-Ethereum address of the Retailer
        address payable consumerID;         // Metamask-Ethereum address of the Consumer
    }

    // Define a public mapping 'items' that maps the UPC to an Item.
    mapping (uint => Item) items;
    
    // Define a public mapping 'itemsHistory' that maps the UPC to an array of TxHash, 
    // that track its journey through the supply chain -- to be sent from DApp.
    mapping (uint => string[]) itemsHistory;

    State constant defaultState = State.SoldToProcessingfactory;

    // Define 11 events with the same 11 state values and accept 'upc' as input argument
    event SoldToProcessingfactory(uint upc);
    event ShippedToProcessingfactory(uint upc);
    event ReceivedByProcessingfactory(uint upc);
    event Working(uint upc);
    event SoldToDistributor(uint upc);
    event ShippedToDistributor(uint upc);
    event ReceivedByDistributor(uint upc);
    event SoldToRetailer(uint upc);
    event ShippedToRetailer(uint upc);
    event ReceivedByRetailer(uint upc);
    event Purchased(uint upc);

    // Define a modifer that checks to see if msg.sender == owner of the contract
    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    // Define a modifer that verifies the Caller
    modifier verifyCaller (address _address) {
        require(msg.sender == _address); 
        _;
    }

    // Define a modifier that checks if the paid amount is sufficient to cover the price
    modifier paidEnough(uint _price) { 
        require(msg.value >= _price); 
        _;
    }
    
    // Define a modifier that checks the price and refunds the remaining balance
    // to the processingfactory
    modifier checkValueProcessingfactory(uint _upc) {
        _;
        uint _price = items[_upc].productprice;
        uint amountToReturn = msg.value - _price;
        items[_upc].processingfactoryID.transfer(amountToReturn);
    }
    
    // Define a modifier that checks the price and refunds the remaining balance
    // to the distributor
    modifier checkValueDistributor(uint _upc) {
        _;
        uint _price = items[_upc].productprice;
        uint amountToReturn = msg.value - _price;
        items[_upc].distributorID.transfer(amountToReturn);
    }
    
    // Define a modifier that checks the price and refunds the remaining balance
    // to the retailer
    modifier checkValueRetailer(uint _upc) {
        _;
        uint _price = items[_upc].productprice;
        uint amountToReturn = msg.value - _price;
        items[_upc].retailerID.transfer(amountToReturn);
    }
    
    // Define a modifier that checks the price and refunds the remaining balance
    // to the consumer
    modifier checkValueConsumer(uint _upc) {
        _;
        uint _price = items[_upc].productprice;
        uint amountToReturn = msg.value - _price;
        items[_upc].consumerID.transfer(amountToReturn);
    }
    
    // Define a modifier that checks if an item.state of a upc is soldToProcessingfactory
    modifier soldToProcessingfactory(uint _upc) {
        require(items[_upc].itemState == State.SoldToProcessingfactory);
        _;
    }

    // Define a modifier that checks if an item.state of a upc is shippedToProcessingfactory
    modifier shippedToProcessingfactory(uint _upc) {
        require(items[_upc].itemState == State.ShippedToProcessingfactory);
        _;
    }
    
    // Define a modifier that checks if an item.state of a upc is receivedByProcessingfactory
    modifier receivedByProcessingfactory(uint _upc) {
        require(items[_upc].itemState == State.ReceivedByProcessingfactory);
        _;
    }
    
    // Define a modifier that checks if an item.state of a upc is working
    modifier working(uint _upc) {
        require(items[_upc].itemState == State.Working);
        _;
    }
    
    // Define a modifier that checks if an item.state of a upc is soldToDistributor
    modifier soldToDistributor(uint _upc) {
        require(items[_upc].itemState == State.SoldToDistributor);
        _;
    }
    
    // Define a modifier that checks if an item.state of a upc is shippedToDistributor
    modifier shippedToDistributor(uint _upc) {
        require(items[_upc].itemState == State.ShippedToDistributor);
        _;
    }
    
    // Define a modifier that checks if an item.state of a upc is receivedByDistributor
    modifier receivedByDistributor(uint _upc) {
        require(items[_upc].itemState == State.ReceivedByDistributor);
        _;
    }
    
    // Define a modifier that checks if an item.state of a upc is soldToRetailer
    modifier soldToRetailer(uint _upc) {
        require(items[_upc].itemState == State.SoldToRetailer);
        _;
    }
    
    // Define a modifier that checks if an item.state of a upc is shippedToRetailer
   modifier shippedToRetailer(uint _upc) {
        require(items[_upc].itemState == State.ShippedToRetailer);
        _;
    }
    
    // Define a modifier that checks if an item.state of a upc is receivedByRetailere
    modifier receivedByRetailer(uint _upc) {
        require(items[_upc].itemState == State.ReceivedByRetailer);
        _;
    }
    
    // Define a modifier that checks if an item.state of a upc is purchased
    modifier purchased(uint _upc) {
        require(items[_upc].itemState == State.Purchased);
        _;
    }
    
    // Check upc is not 0
    modifier checkupcTF(uint _upc) {
        require(_upc>0,"UPC can't be zero");
        _;
    }
    
    // Check upc is not repeat
    modifier checkitemTF(uint _upc) {
        require(items[_upc].upc != _upc, "Item already exists with the given upc");
        _;
    }
    
    // Check price > 0
    modifier checkpriceTF(uint _price) {
        require(_price>0, "Price is not greater than zero");
        _;
    }

    // In the constructor set 'owner' to the address that instantiated the contract
    // and set 'sku' to 1
    // and set 'upc' to 1
    constructor() public payable {
        owner = msg.sender;
        sku = 1;
        upc = 1;
    }

    function soldToProcessingfactoryItem(uint _upc, string memory  _notes, uint _price) public 
    checkupcTF(_upc)
    checkitemTF(_upc)
    checkpriceTF(_price)
    onlySupplier
    {
        Item memory newItem;
        newItem.sku = sku;
        newItem.upc = _upc;
        newItem.ownerID = msg.sender;
        newItem.originID = msg.sender;
        newItem.productID = sku + upc;
        newItem.productNotes = _notes;
        newItem.productprice = _price;
        newItem.itemState = State.SoldToProcessingfactory;
        items[_upc] = newItem;
        // Increment sku
        sku = sku + 1;

        emit SoldToProcessingfactory(_upc);

    }

   
    function shippedToProcessingfactoryItem(uint _upc) public
    soldToProcessingfactory(_upc) 
    onlyTransporter
    {
        Item storage existItem = items[_upc];
        existItem.ownerID = msg.sender;
        existItem.itemState = State.ShippedToProcessingfactory;
        existItem.transporterID = msg.sender;

        emit ShippedToProcessingfactory(_upc);
    }

    function receivedByProcessingfactoryItem(uint _upc) public
    shippedToProcessingfactory(_upc)
    onlyProcessingfactory
    {
        Item storage existItem = items[_upc];
        existItem.ownerID = msg.sender;
        existItem.itemState = State.ReceivedByProcessingfactory;
        existItem.processingfactoryID = msg.sender;
        
        emit ReceivedByProcessingfactory(_upc);
    }

    function workingItem(uint _upc) public 
    receivedByProcessingfactory(_upc) 
    onlyProcessingfactory
    verifyCaller(items[_upc].processingfactoryID)
    {

        Item storage existItem = items[_upc];
        existItem.itemState = State.Working;

        emit Working(_upc);
    }

    function soldToDistributorItem(uint _upc, uint price) public 
    working(_upc)
    onlyProcessingfactory
    verifyCaller(items[_upc].processingfactoryID)
    {
        Item storage existItem = items[_upc];
        existItem.itemState = State.SoldToDistributor;
        existItem.productprice += price;
        
        emit SoldToDistributor(_upc);
    }
    

    function shippedToDistributorItem(uint _upc) public
    soldToDistributor(_upc)
    onlyTransporter
    {
        Item storage existItem = items[_upc];
        existItem.ownerID = msg.sender;
        existItem.itemState = State.ShippedToDistributor;
        existItem.transporterID = msg.sender;
        
        emit ShippedToDistributor(_upc);        
    }

    function receivedByDistributorItem(uint _upc) public
    shippedToDistributor(_upc) 
    onlyDistributor
    {
        Item storage existItem = items[_upc];
        existItem.ownerID = msg.sender;
        existItem.itemState = State.ReceivedByDistributor;
        existItem.distributorID = msg.sender;
        emit ReceivedByDistributor(_upc);
    } 

    function soldToRetailerItem(uint _upc, uint price) public
    receivedByDistributor(_upc)
    onlyDistributor
    verifyCaller(items[_upc].distributorID)
    {
        Item storage existItem = items[_upc];
        //require(i.ownerID == msg.sender,"Not the retailer of the given upc");
        existItem.itemState = State.SoldToRetailer;
        existItem.productprice += price;
        
        emit SoldToRetailer(_upc);
    }
    

    function shippedToRetailerItem(uint _upc) public
    soldToRetailer(_upc)
    onlyTransporter
    {
        Item storage existItem = items[_upc];
        existItem.ownerID = msg.sender;
        existItem.itemState = State.ShippedToRetailer;
        existItem.transporterID = msg.sender;
        
        emit ShippedToRetailer(_upc);        
    }

    function receivedByRetailerItem(uint _upc, uint _price) public
    shippedToRetailer(_upc) 
    onlyRetailer
    {
        Item storage existItem = items[_upc];
        //require(i.retailerID == msg.sender, "Only the retailer of that smartphone can ship");
        existItem.itemState = State.ReceivedByRetailer;
        existItem.productprice += _price;

        emit ReceivedByRetailer(_upc);
    }
    
    function purchasedItem(uint _upc) public
    receivedByRetailer(_upc) 
    onlyConsumer
    {
        Item storage existItem = items[_upc];
        existItem.itemState = State.Purchased;

        emit ReceivedByRetailer(_upc);
    }
    
  // Define a function 'fetchItemBufferTwo' that fetches the data
  function fetchItemBuffer(uint _upc) public view returns 
  (
  uint    itemSKU,
  uint    itemUPC,
  uint    productID,
  string  memory productNotes,
  uint    productprice,
  uint    itemState
  ) 
  {
    // Assign values to the 9 parameters
  Item memory existingItem = items[_upc];
  itemSKU = existingItem.sku;
  itemUPC = existingItem.upc;
  productID = existingItem.productID;
  productNotes = existingItem.productNotes;
  productprice = existingItem.productprice;
  itemState = uint(existingItem.itemState);
  
  return 
  (
  itemSKU,
  itemUPC,
  productID,
  productNotes,
  productprice,
  itemState
  );
  }

}